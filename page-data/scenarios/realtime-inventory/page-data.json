{"componentChunkName":"component---src-pages-scenarios-realtime-inventory-index-mdx","path":"/scenarios/realtime-inventory/","result":{"pageContext":{"frontmatter":{"title":"Near real-time Inventory, powered by IBM Event Streams","description":"An end-to-end data pipeline lab scenario, connecting multiple components of a realtime inventory system via Kafka Connect."},"relativePagePath":"/scenarios/realtime-inventory/index.mdx","titleType":"append","MdxNode":{"id":"645ba643-c2fb-5b45-9f6a-93fcb3400b19","children":[],"parent":"1397c2b6-79ae-57a1-adc3-d7c425fab022","internal":{"content":"---\ntitle: Near real-time Inventory, powered by IBM Event Streams\ndescription: An end-to-end data pipeline lab scenario, connecting multiple components of a realtime inventory system via Kafka Connect.\n---\n\nAn IBM Cloud Pak for Integration - Event Streams use case\n\n<InlineNotification kind=\"warning\">\n<strong>Updated 02/22/2022</strong> - Work in progress\n</InlineNotification>\n\n<AnchorLinks>\n  <AnchorLink>Introduction</AnchorLink>\n  <AnchorLink>Use Case Guided Tour</AnchorLink>\n  <AnchorLink>Full Demo Narration</AnchorLink>\n  <AnchorLink>Developer Corner</AnchorLink>\n </AnchorLinks>\n\n----\n# Introduction \n\n## Use Case Overview\n\nToday, a lot of companies which are managing item / product inventory are facing real challenges to get a close to real-time view of item availability\nand global inventory view. The solution can be very complex to implement while integrating Enterprise Resource Planning products and other custom legacy systems. \nAny new solutions are adopting events as a source to exchange data, to put less pressure on existing ERP servers, and to get better visibility \ninto inventory positions while bringing agility to develop new solution with streaming components.\n\nThis scenario implements a simple near real-time inventory management solution based on real life MVPs we developed in 2020 for different customers. \nA production deployment will implement different level of store and warehouse inventory aggregators that will push results as event to an event backbone.\nThose aggregates are used to build different data caching services, adnd to address use cases such as item availability.\n\nAt the high-level, the solution may look like in the following figure:\n\n![](./images/hl-view.png)\n\nServers in the Store are sending sale transactions to a central messaging platform, where streaming components are computing the different aggregates \nand are publishing them to other topics. This is a classical data streaming pipeline. Sink connectors, based on Kafka Connect framework,\n may be used to move data to long persistence storage like a Database, integrate results back to Legacy ERP, use indexing like Elastic Search, \n propagate events to dashboards...\n\nIn real life, an as-is solution will include back-end applications to manage the warehouses inventory, connected to a home-built fulfillment application,\ncombined with store applications and servers, e-commerce suite, and a set of SOA services exposing backend systems. This is the larger view of the\nfollowing figure:\n\n ![](./images/as-is-soa.png)\n\nWe may have integration flows to do data mapping, but most of those calls are synchronous.  To get one item availability, a lot of SOAP calls are done, \nincreasing latency, and the risk of failure. There is [an interesting video](https://www.youtube.com/watch?v=FskIb9SariI) from Scott Havens explaining the needs \nfrom transitioning from a synchronous architecture to an event-driven asynchronous architecture when scaling, and low latency are must have. \nThis lab reflects this approach.\n\n## Demonstration components\n\nIn this demonstration we are deploying the following components:\n\n![](./images/mq-es-demo.png)\n\nDiagram source: [rt-inventory diagram](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/blob/main/docs/diagrams/mq-es-demo.drawio)\n\n1. The [store simulator application](https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator) is a Quarkus based microservice, used to generate item sales \nto different possible messaging middlewares ( RabbitMQ, IBM MQ or directly to IBM Event Streams). \nIf you want to browse the code, the main readme of this project includes how to package and run this app with docker compose. A code explanation\nsection may give some ideas to developers. The docker image is [quay.io/ibmcase/eda-store-simulator/](https://quay.io/ibmcase/eda-store-simulator) and can be used for demonstration.\n1. The item inventory aggregator is a Kafka Stream, Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-item-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-item-inventory). \nConsider this more as a black box in the context of the scenario, it consumes items events, aggregate them, expose APIs on top of Kafka Streams interactive queries and publish inventory events on `item.inventory` topic. \nAs a developer you may want to understand Kafka Stream programming with the [following labs](/use-cases/kafka-streams/), and then considering looking at the classes: [ItemProcessingAgent.java](https://github.com/ibm-cloud-architecture/refarch-eda-item-inventory/blob/master/src/main/java/ibm/gse/eda/inventory/domain/ItemProcessingAgent.java).\n1. The store inventory aggregator is a Kafka Stream Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-store-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-store-inventory). The output is in `store.inventory` topic. \n1. The MQ to Kafka, Kafka connector is defined in the [eda-rt-inventory-GitOps](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops) repository under the [kconnect](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/tree/main/kconnect) folder\n1. The Kafka to Cloud Object Storage Kafka connector is also defined in the same [GitOps repository/folder](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops).\n\n[Kafka Connect](/technology/kafka-connect/) is used to integrate external systems into Kafka. For example external systems can inject item sale messages to queue, from which a first MQ source Kafka connector \npublishes the messages to the `items` Kafka topic. Items sold events are processed by a series of streaming microservices down to different topics to keep aggregation results.\nThose topics content could be which will be used by Sink connectors\n to send records to other external systems.\n\n## A GitOps approach for solution deployment\n\nAs any cloud-native and kubernetes based solution, we use continuous integration and continuous deployment practices. From a demonstration point of view, the most interesting part is\nto execute continuous deployment using a [GitOps approach](/use-cases/gitops/). This demonstration has a [GitOps repository](https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git) \n(represented as the yellow rectangle in figure below) which defines ArgoCD apps \nto monitor and deploy the different microservices, streaming processing apps,\nand the different IBM products needed: Event Streams, MQ, API management, event-end-point management. The figure belows presents the adopted strategy:\n\n![](./images/gitops-catalog.png)\n\nThe [gitops catalog repository](https://github.com/ibm-cloud-architecture/eda-gitops-catalog.git), represented with a blue rectangle, defines the different operator subscriptions\nfor the cloud pak for integration components. Centralizing to one repository such operator subscriptions enforces reuse between solutions.\n\nThe solution [gitops](https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git) was created with [KAM CLI](https://github.com/redhat-developer/kam) and is structured as follow:\n\n* **Boostrap** folder: to install different operators and to define the ArgoCD project named `rt-inventory`.\n* **config** folder, is for defining the ArgoCD apps and the app of apps. \n* **kconnect** folder is used to build a custom docker image of Kafka connector with MQ source, Elasticsearch sink and Cloud Object storage sink.\n* **local-demo** folder is for running the solution on your laptop using docker-compose.\n* **environments** folder, is the most important one, it use [Kustomize](https://kustomize.io/) to declare environments (dev, staging) and component deployents. \n\n### A little bit more on environment\n\nFor demonstration purpose, only the `rt-inventory-dev` environment is detailed. One ArgoCD app: [rt-inventory-dev-env](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/blob/main/config/argocd/rt-inventory-dev-env-app.yaml) is monitoring\n the folder [environments/rt-inventory-dev/env/overlays](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/tree/main/environments/rt-inventory-dev/env/overlays) which define the namespace and roles,... \nEach application of the solution are also monitored by an ArgoCD and their declarations are done using standard kubernetes manifests. Here is an exampe of app tree structure:\n\n```\n── store-inventory\n│   ├── base\n│   │   └── kustomization.yaml\n│   ├── kustomization.yaml\n│   ├── overlays\n│   │   └── kustomization.yaml\n│   └── services\n│       └── store-inventory\n│           ├── base\n│           │   ├── config\n│           │   │   ├── configmap.yaml\n│           │   │   ├── deployment.yaml\n│           │   │   ├── kustomization.yaml\n│           │   │   ├── rolebinding.yaml\n│           │   │   ├── route.yaml\n│           │   │   ├── service.yaml\n│           │   │   └── serviceaccount.yaml\n│           │   └── kustomization.yaml\n│           ├── kustomization.yaml\n│           └── overlays\n│               └── kustomization.yaml\n```\n\nThe last intesting part is to declare the products used within the Cloud Pak for integration, and deployed in the context of\nthe respective environment. Everything is in `service` folder:\n\n```\n── apicurio\n│   ├── base\n│   │   ├── es-kafka-topics.yaml\n│   │   ├── kustomization.yaml\n│   │   └── registry.yaml\n│   └── overlays\n│       └── kustomization.yaml\n├── event-endpoint\n│   ├── base\n│   │   ├── eventendpointmanager-eepm-eda.yaml\n│   │   └── kustomization.yaml\n│   └── overlays\n│       ├── kustomization.yaml\n│       └── v10.0.4.0\n│           ├── kustomization.yaml\n│           └── patch-version.yaml\n├── ibm-eventstreams\n│   ├── base\n│   │   ├── es-topics.yaml\n│   │   ├── eventstreams-dev.yaml\n│   │   ├── kustomization.yaml\n│   │   ├── scram-user.yaml\n│   │   └── tls-user.yaml\n│   └── overlays\n│       ├── kustomization.yaml\n│       └── v10.5\n│           ├── kustomization.yaml\n│           └── patch-version.yaml\n├── ibm-mq\n│   ├── base\n│   │   ├── kustomization.yaml\n│   │   └── qmgr.yaml\n│   └── overlays\n│       ├── kustomization.yaml\n│       └── v9.2.4\n│           ├── kustomization.yaml\n│           └── patch-channel.yaml\n├── kconnect\n│   ├── README.md\n│   ├── kafka-connect.yaml\n│   ├── kafka-cos-sink-connector.yaml\n│   ├── kustomization.yaml\n│   └── mq-source.json\n└── kustomization.yaml\n```\n\nWith the public docker images, and this public GitOps, the solution can be deployed in few minutes to an OpenShift cluster with or without Cloud Pak for Integration already deployed.\n\n## Choose an option:\n\n* [Run on your laptop](/#run-on-your-laptop)\n* [Run on OpenShift](/#install-yourself-on-openshift)\n\n### Pre-requisites for both options\n\n* [Docker](https://docs.docker.com/) and docker compose to run the solution locally.\n* [git CLI](https://git-scm.com/downloads).\n* Clone the Inventory lab repository: \n\n  ```sh\n  git clone  https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git\n  ```\n\n\n### Run on your laptop\n\nAs a developer or technical seller you could demonstrate this scenario on your laptop. \nThe docker images used in this solution are in public registry ([Quay.io](https://recovery.quay.io/organization/ibmcase)), the docker compose in\nthe [rt-inventory-gitops.git](https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git) local-demo/kstream [folder](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/tree/main/local-demo/kstreams) \nuses IBM Event Streams, IBM MQ Images, Kafka Connect and the custom images of the services.\n\nOnce you have cloned the gitops repository (see pre-requisites section), go under the `local-demo/kstreams` folder and run\n\n  ```sh\n  docker-compose up -d\n  ```\n\n  To stop the demonstration do the following command:\n\n  ```sh\n  docker-compose down\n  ```\n\nThe demonstration script is the same as below, except that we use Kafdrop to visualize the content of Event Streams topics. \nSee [this section](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops#run-the-solution-locally) in the main readme.\n\n### Install Yourself on OpenShift\n\nIn this approach, we propose to use a GitOps repository and deploy the solution using few scripts and `oc` CLI commands.\n\n![](./images/hl-view.png)\n\n--- \n\n# Use Case Guided Tour\n\n## Bootstrap GitOps\n\nFollow [these instructions](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops#bootstrap_gitops) from the gitops main readme.\n\n## Deploy the Solution\n\n```sh\n  oc project rt-inventory-dev\n  oc get pods\n\n  NAME                                         READY   STATUS    RESTARTS   AGE\n  dev-kafka-cruise-control-6d6bf8b774-99rwl    2/2     Running   0          4d\n  dev-kafka-entity-operator-75f7bc8f5c-x4vkt   3/3     Running   0          4d\n  dev-kafka-kafka-0                            1/1     Running   0          4d\n  dev-kafka-kafka-1                            1/1     Running   0          4d\n  dev-kafka-kafka-2                            1/1     Running   0          4d\n  dev-kafka-zookeeper-0                        1/1     Running   0          4d\n  dev-kafka-zookeeper-1                        1/1     Running   0          4d\n  dev-kafka-zookeeper-2                        1/1     Running   0          4d\n  item-aggregator-669fd4fffc-4fvhk             1/1     Running   0          30h\n  item-aggregator-669fd4fffc-gtvls             1/1     Running   0          30h\n  item-aggregator-669fd4fffc-kxvfh             1/1     Running   0          30h\n  store-aggregator-7df98556ff-cxjz5            1/1     Running   0          29h\n  store-aggregator-7df98556ff-dl9wz            1/1     Running   0          29h\n  store-aggregator-7df98556ff-f2ndq            1/1     Running   0          29h\n  store-simulator-56f8958498-mvhp9             1/1     Running   0          4d\n  ```\n\n## Demonstrate the real-time processing\n\n1. To get this route use the following command and start a Web Browser\n\n  ```sh\n  chrome $(oc get routes store-simulator  -o jsonpath=\"{.spec.host}\")\n  ```\n\n  You should reach the Home page of the simulator\n\n  ![](./images/home-page.png)\n\n1. Look at existing stores\n\n  ![](./images/stores-view.png)\n\n1. Start the predefined scenario\n\n  ![](./images/start-simulation.png)\n\n  once started a table should be displayed to present the records sent to Kafka. \n\n  ![](./images/send-msgs.png) \n\n1. Verify messages are in queue\n\n![](./images/qm1-qm.png)\n\n![](./images/msg-in-queue.png)\n\n\n![](./images/one-msg-queue.png)\n\n\n\n1. Let assess if we can see the item stock cross stores: use the item-aggregator route, something like ` item-aggregator-rt-inventory.dte-ocp46-73awfj-915b3b336cabec458a7c7ec2aa7c625f-0000.us-east.containers.appdomain.cloud ` but completed with '/q/swagger-ui' as we want to access the API\n  \n  To get this route use the following command:\n\n  ```sh\n  oc get routes item-aggregator -o jsonpath=\"{.spec.host}\" && echo\n  ```\n\n   Select the get `/api/v1/items/{itemID}` operation:\n\n  ![](./images/items-stock-req.png)\n\n  Use one of the following item id: [Item_1, Item_2, Item_3, Item_4, Item_5, Item_6, Item_7]. You should get \n  the current stock cross stores\n\n  ![](./images/item-stock-response.png)\n\n1. Let assess a store stock, for that we access the store aggregator URL: `store-aggregator-rt-inventory.dte-ocp46-73awfj-915b3b336cabec458a7c7ec2aa7c625f-0000.us-east.containers.appdomain.cloud ` with the `/q/swagger-ui` suffix.\n\n  To get this route use the following command:\n\n  ```sh\n  oc get routes store-aggregator -o jsonpath=\"{.spec.host}\" && echo\n  ```\n\n  Then use the GET on the `api/v1/stores/inventory/{storeID}`, and enter one of the available store: `[Store_1, Store_2, Store_3, Store_4, Store_5]`\n\n  ![](./images/store-stock-req.png)\n\n  The response should look like:\n\n  ![](./images/store-stock-response.png)\n\n---\n\n# Full Demo Narration\n\nWe will first go over the demonstration using the store simulator then using and end to end test script\n\n\n---\n\n# Developer Corner\n\n## What you will learn\n\n* Use Quarkus, with reactive programming API like Mutiny, and Kafka API to produce messages to Kafka\n* Same Quarkus app can generate messages to RabbitMQ using the AMQP API\n* Same Quarkus app can generate messages to IBM MQ using JMS\n* Use Quarkus and Kafka Streams to compute aggregates to build an inventory view from the stream of sale order events\n* Use the IBM MQ source connector from IBM Event messaging open source contribution\n\n\n## Solution anatomy\n\n1. The [store simulator application](https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator) is a Quarkus app, which generates item sales to different possible messaging middlewares ( RabbitMQ, MQ or directly to Kafka). \nThe code of this application is in this https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator. If you want to browse the code, the main readme of this project includes how to package and run this app with docker compose, \nand explains how the code works. \nThe docker image is [quay.io/ibmcase/eda-store-simulator/](https://quay.io/ibmcase/eda-store-simulator)\n1. The item inventory aggregator is a Kafka Stream Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-item-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-item-inventory). \nConsider this more as a black box in the context of the scenario, it consumes items events, aggregate them, expose APIs on top of Kafka Streams interactive queries and publish inventory events on `item.inventory` topic. \n1. The store inventory aggregator is a Kafka Stream Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-store-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-store-inventory) the output is in `store.inventory` topic. \n2. The mock up Inventory mainframe application is not implemented and we will use the MQ tools to view the message in the `item.inventory` MQ queue.\n\n \n\n","type":"Mdx","contentDigest":"1f13d55b02412914ef6df9076728e2a2","owner":"gatsby-plugin-mdx","counter":827},"frontmatter":{"title":"Near real-time Inventory, powered by IBM Event Streams","description":"An end-to-end data pipeline lab scenario, connecting multiple components of a realtime inventory system via Kafka Connect."},"exports":{},"rawBody":"---\ntitle: Near real-time Inventory, powered by IBM Event Streams\ndescription: An end-to-end data pipeline lab scenario, connecting multiple components of a realtime inventory system via Kafka Connect.\n---\n\nAn IBM Cloud Pak for Integration - Event Streams use case\n\n<InlineNotification kind=\"warning\">\n<strong>Updated 02/22/2022</strong> - Work in progress\n</InlineNotification>\n\n<AnchorLinks>\n  <AnchorLink>Introduction</AnchorLink>\n  <AnchorLink>Use Case Guided Tour</AnchorLink>\n  <AnchorLink>Full Demo Narration</AnchorLink>\n  <AnchorLink>Developer Corner</AnchorLink>\n </AnchorLinks>\n\n----\n# Introduction \n\n## Use Case Overview\n\nToday, a lot of companies which are managing item / product inventory are facing real challenges to get a close to real-time view of item availability\nand global inventory view. The solution can be very complex to implement while integrating Enterprise Resource Planning products and other custom legacy systems. \nAny new solutions are adopting events as a source to exchange data, to put less pressure on existing ERP servers, and to get better visibility \ninto inventory positions while bringing agility to develop new solution with streaming components.\n\nThis scenario implements a simple near real-time inventory management solution based on real life MVPs we developed in 2020 for different customers. \nA production deployment will implement different level of store and warehouse inventory aggregators that will push results as event to an event backbone.\nThose aggregates are used to build different data caching services, adnd to address use cases such as item availability.\n\nAt the high-level, the solution may look like in the following figure:\n\n![](./images/hl-view.png)\n\nServers in the Store are sending sale transactions to a central messaging platform, where streaming components are computing the different aggregates \nand are publishing them to other topics. This is a classical data streaming pipeline. Sink connectors, based on Kafka Connect framework,\n may be used to move data to long persistence storage like a Database, integrate results back to Legacy ERP, use indexing like Elastic Search, \n propagate events to dashboards...\n\nIn real life, an as-is solution will include back-end applications to manage the warehouses inventory, connected to a home-built fulfillment application,\ncombined with store applications and servers, e-commerce suite, and a set of SOA services exposing backend systems. This is the larger view of the\nfollowing figure:\n\n ![](./images/as-is-soa.png)\n\nWe may have integration flows to do data mapping, but most of those calls are synchronous.  To get one item availability, a lot of SOAP calls are done, \nincreasing latency, and the risk of failure. There is [an interesting video](https://www.youtube.com/watch?v=FskIb9SariI) from Scott Havens explaining the needs \nfrom transitioning from a synchronous architecture to an event-driven asynchronous architecture when scaling, and low latency are must have. \nThis lab reflects this approach.\n\n## Demonstration components\n\nIn this demonstration we are deploying the following components:\n\n![](./images/mq-es-demo.png)\n\nDiagram source: [rt-inventory diagram](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/blob/main/docs/diagrams/mq-es-demo.drawio)\n\n1. The [store simulator application](https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator) is a Quarkus based microservice, used to generate item sales \nto different possible messaging middlewares ( RabbitMQ, IBM MQ or directly to IBM Event Streams). \nIf you want to browse the code, the main readme of this project includes how to package and run this app with docker compose. A code explanation\nsection may give some ideas to developers. The docker image is [quay.io/ibmcase/eda-store-simulator/](https://quay.io/ibmcase/eda-store-simulator) and can be used for demonstration.\n1. The item inventory aggregator is a Kafka Stream, Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-item-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-item-inventory). \nConsider this more as a black box in the context of the scenario, it consumes items events, aggregate them, expose APIs on top of Kafka Streams interactive queries and publish inventory events on `item.inventory` topic. \nAs a developer you may want to understand Kafka Stream programming with the [following labs](/use-cases/kafka-streams/), and then considering looking at the classes: [ItemProcessingAgent.java](https://github.com/ibm-cloud-architecture/refarch-eda-item-inventory/blob/master/src/main/java/ibm/gse/eda/inventory/domain/ItemProcessingAgent.java).\n1. The store inventory aggregator is a Kafka Stream Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-store-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-store-inventory). The output is in `store.inventory` topic. \n1. The MQ to Kafka, Kafka connector is defined in the [eda-rt-inventory-GitOps](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops) repository under the [kconnect](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/tree/main/kconnect) folder\n1. The Kafka to Cloud Object Storage Kafka connector is also defined in the same [GitOps repository/folder](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops).\n\n[Kafka Connect](/technology/kafka-connect/) is used to integrate external systems into Kafka. For example external systems can inject item sale messages to queue, from which a first MQ source Kafka connector \npublishes the messages to the `items` Kafka topic. Items sold events are processed by a series of streaming microservices down to different topics to keep aggregation results.\nThose topics content could be which will be used by Sink connectors\n to send records to other external systems.\n\n## A GitOps approach for solution deployment\n\nAs any cloud-native and kubernetes based solution, we use continuous integration and continuous deployment practices. From a demonstration point of view, the most interesting part is\nto execute continuous deployment using a [GitOps approach](/use-cases/gitops/). This demonstration has a [GitOps repository](https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git) \n(represented as the yellow rectangle in figure below) which defines ArgoCD apps \nto monitor and deploy the different microservices, streaming processing apps,\nand the different IBM products needed: Event Streams, MQ, API management, event-end-point management. The figure belows presents the adopted strategy:\n\n![](./images/gitops-catalog.png)\n\nThe [gitops catalog repository](https://github.com/ibm-cloud-architecture/eda-gitops-catalog.git), represented with a blue rectangle, defines the different operator subscriptions\nfor the cloud pak for integration components. Centralizing to one repository such operator subscriptions enforces reuse between solutions.\n\nThe solution [gitops](https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git) was created with [KAM CLI](https://github.com/redhat-developer/kam) and is structured as follow:\n\n* **Boostrap** folder: to install different operators and to define the ArgoCD project named `rt-inventory`.\n* **config** folder, is for defining the ArgoCD apps and the app of apps. \n* **kconnect** folder is used to build a custom docker image of Kafka connector with MQ source, Elasticsearch sink and Cloud Object storage sink.\n* **local-demo** folder is for running the solution on your laptop using docker-compose.\n* **environments** folder, is the most important one, it use [Kustomize](https://kustomize.io/) to declare environments (dev, staging) and component deployents. \n\n### A little bit more on environment\n\nFor demonstration purpose, only the `rt-inventory-dev` environment is detailed. One ArgoCD app: [rt-inventory-dev-env](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/blob/main/config/argocd/rt-inventory-dev-env-app.yaml) is monitoring\n the folder [environments/rt-inventory-dev/env/overlays](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/tree/main/environments/rt-inventory-dev/env/overlays) which define the namespace and roles,... \nEach application of the solution are also monitored by an ArgoCD and their declarations are done using standard kubernetes manifests. Here is an exampe of app tree structure:\n\n```\n── store-inventory\n│   ├── base\n│   │   └── kustomization.yaml\n│   ├── kustomization.yaml\n│   ├── overlays\n│   │   └── kustomization.yaml\n│   └── services\n│       └── store-inventory\n│           ├── base\n│           │   ├── config\n│           │   │   ├── configmap.yaml\n│           │   │   ├── deployment.yaml\n│           │   │   ├── kustomization.yaml\n│           │   │   ├── rolebinding.yaml\n│           │   │   ├── route.yaml\n│           │   │   ├── service.yaml\n│           │   │   └── serviceaccount.yaml\n│           │   └── kustomization.yaml\n│           ├── kustomization.yaml\n│           └── overlays\n│               └── kustomization.yaml\n```\n\nThe last intesting part is to declare the products used within the Cloud Pak for integration, and deployed in the context of\nthe respective environment. Everything is in `service` folder:\n\n```\n── apicurio\n│   ├── base\n│   │   ├── es-kafka-topics.yaml\n│   │   ├── kustomization.yaml\n│   │   └── registry.yaml\n│   └── overlays\n│       └── kustomization.yaml\n├── event-endpoint\n│   ├── base\n│   │   ├── eventendpointmanager-eepm-eda.yaml\n│   │   └── kustomization.yaml\n│   └── overlays\n│       ├── kustomization.yaml\n│       └── v10.0.4.0\n│           ├── kustomization.yaml\n│           └── patch-version.yaml\n├── ibm-eventstreams\n│   ├── base\n│   │   ├── es-topics.yaml\n│   │   ├── eventstreams-dev.yaml\n│   │   ├── kustomization.yaml\n│   │   ├── scram-user.yaml\n│   │   └── tls-user.yaml\n│   └── overlays\n│       ├── kustomization.yaml\n│       └── v10.5\n│           ├── kustomization.yaml\n│           └── patch-version.yaml\n├── ibm-mq\n│   ├── base\n│   │   ├── kustomization.yaml\n│   │   └── qmgr.yaml\n│   └── overlays\n│       ├── kustomization.yaml\n│       └── v9.2.4\n│           ├── kustomization.yaml\n│           └── patch-channel.yaml\n├── kconnect\n│   ├── README.md\n│   ├── kafka-connect.yaml\n│   ├── kafka-cos-sink-connector.yaml\n│   ├── kustomization.yaml\n│   └── mq-source.json\n└── kustomization.yaml\n```\n\nWith the public docker images, and this public GitOps, the solution can be deployed in few minutes to an OpenShift cluster with or without Cloud Pak for Integration already deployed.\n\n## Choose an option:\n\n* [Run on your laptop](/#run-on-your-laptop)\n* [Run on OpenShift](/#install-yourself-on-openshift)\n\n### Pre-requisites for both options\n\n* [Docker](https://docs.docker.com/) and docker compose to run the solution locally.\n* [git CLI](https://git-scm.com/downloads).\n* Clone the Inventory lab repository: \n\n  ```sh\n  git clone  https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git\n  ```\n\n\n### Run on your laptop\n\nAs a developer or technical seller you could demonstrate this scenario on your laptop. \nThe docker images used in this solution are in public registry ([Quay.io](https://recovery.quay.io/organization/ibmcase)), the docker compose in\nthe [rt-inventory-gitops.git](https://github.com/ibm-cloud-architecture/rt-inventory-gitops.git) local-demo/kstream [folder](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops/tree/main/local-demo/kstreams) \nuses IBM Event Streams, IBM MQ Images, Kafka Connect and the custom images of the services.\n\nOnce you have cloned the gitops repository (see pre-requisites section), go under the `local-demo/kstreams` folder and run\n\n  ```sh\n  docker-compose up -d\n  ```\n\n  To stop the demonstration do the following command:\n\n  ```sh\n  docker-compose down\n  ```\n\nThe demonstration script is the same as below, except that we use Kafdrop to visualize the content of Event Streams topics. \nSee [this section](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops#run-the-solution-locally) in the main readme.\n\n### Install Yourself on OpenShift\n\nIn this approach, we propose to use a GitOps repository and deploy the solution using few scripts and `oc` CLI commands.\n\n![](./images/hl-view.png)\n\n--- \n\n# Use Case Guided Tour\n\n## Bootstrap GitOps\n\nFollow [these instructions](https://github.com/ibm-cloud-architecture/eda-rt-inventory-gitops#bootstrap_gitops) from the gitops main readme.\n\n## Deploy the Solution\n\n```sh\n  oc project rt-inventory-dev\n  oc get pods\n\n  NAME                                         READY   STATUS    RESTARTS   AGE\n  dev-kafka-cruise-control-6d6bf8b774-99rwl    2/2     Running   0          4d\n  dev-kafka-entity-operator-75f7bc8f5c-x4vkt   3/3     Running   0          4d\n  dev-kafka-kafka-0                            1/1     Running   0          4d\n  dev-kafka-kafka-1                            1/1     Running   0          4d\n  dev-kafka-kafka-2                            1/1     Running   0          4d\n  dev-kafka-zookeeper-0                        1/1     Running   0          4d\n  dev-kafka-zookeeper-1                        1/1     Running   0          4d\n  dev-kafka-zookeeper-2                        1/1     Running   0          4d\n  item-aggregator-669fd4fffc-4fvhk             1/1     Running   0          30h\n  item-aggregator-669fd4fffc-gtvls             1/1     Running   0          30h\n  item-aggregator-669fd4fffc-kxvfh             1/1     Running   0          30h\n  store-aggregator-7df98556ff-cxjz5            1/1     Running   0          29h\n  store-aggregator-7df98556ff-dl9wz            1/1     Running   0          29h\n  store-aggregator-7df98556ff-f2ndq            1/1     Running   0          29h\n  store-simulator-56f8958498-mvhp9             1/1     Running   0          4d\n  ```\n\n## Demonstrate the real-time processing\n\n1. To get this route use the following command and start a Web Browser\n\n  ```sh\n  chrome $(oc get routes store-simulator  -o jsonpath=\"{.spec.host}\")\n  ```\n\n  You should reach the Home page of the simulator\n\n  ![](./images/home-page.png)\n\n1. Look at existing stores\n\n  ![](./images/stores-view.png)\n\n1. Start the predefined scenario\n\n  ![](./images/start-simulation.png)\n\n  once started a table should be displayed to present the records sent to Kafka. \n\n  ![](./images/send-msgs.png) \n\n1. Verify messages are in queue\n\n![](./images/qm1-qm.png)\n\n![](./images/msg-in-queue.png)\n\n\n![](./images/one-msg-queue.png)\n\n\n\n1. Let assess if we can see the item stock cross stores: use the item-aggregator route, something like ` item-aggregator-rt-inventory.dte-ocp46-73awfj-915b3b336cabec458a7c7ec2aa7c625f-0000.us-east.containers.appdomain.cloud ` but completed with '/q/swagger-ui' as we want to access the API\n  \n  To get this route use the following command:\n\n  ```sh\n  oc get routes item-aggregator -o jsonpath=\"{.spec.host}\" && echo\n  ```\n\n   Select the get `/api/v1/items/{itemID}` operation:\n\n  ![](./images/items-stock-req.png)\n\n  Use one of the following item id: [Item_1, Item_2, Item_3, Item_4, Item_5, Item_6, Item_7]. You should get \n  the current stock cross stores\n\n  ![](./images/item-stock-response.png)\n\n1. Let assess a store stock, for that we access the store aggregator URL: `store-aggregator-rt-inventory.dte-ocp46-73awfj-915b3b336cabec458a7c7ec2aa7c625f-0000.us-east.containers.appdomain.cloud ` with the `/q/swagger-ui` suffix.\n\n  To get this route use the following command:\n\n  ```sh\n  oc get routes store-aggregator -o jsonpath=\"{.spec.host}\" && echo\n  ```\n\n  Then use the GET on the `api/v1/stores/inventory/{storeID}`, and enter one of the available store: `[Store_1, Store_2, Store_3, Store_4, Store_5]`\n\n  ![](./images/store-stock-req.png)\n\n  The response should look like:\n\n  ![](./images/store-stock-response.png)\n\n---\n\n# Full Demo Narration\n\nWe will first go over the demonstration using the store simulator then using and end to end test script\n\n\n---\n\n# Developer Corner\n\n## What you will learn\n\n* Use Quarkus, with reactive programming API like Mutiny, and Kafka API to produce messages to Kafka\n* Same Quarkus app can generate messages to RabbitMQ using the AMQP API\n* Same Quarkus app can generate messages to IBM MQ using JMS\n* Use Quarkus and Kafka Streams to compute aggregates to build an inventory view from the stream of sale order events\n* Use the IBM MQ source connector from IBM Event messaging open source contribution\n\n\n## Solution anatomy\n\n1. The [store simulator application](https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator) is a Quarkus app, which generates item sales to different possible messaging middlewares ( RabbitMQ, MQ or directly to Kafka). \nThe code of this application is in this https://github.com/ibm-cloud-architecture/refarch-eda-store-simulator. If you want to browse the code, the main readme of this project includes how to package and run this app with docker compose, \nand explains how the code works. \nThe docker image is [quay.io/ibmcase/eda-store-simulator/](https://quay.io/ibmcase/eda-store-simulator)\n1. The item inventory aggregator is a Kafka Stream Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-item-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-item-inventory). \nConsider this more as a black box in the context of the scenario, it consumes items events, aggregate them, expose APIs on top of Kafka Streams interactive queries and publish inventory events on `item.inventory` topic. \n1. The store inventory aggregator is a Kafka Stream Quarkus application, done with Kafka Stream API. The source code is in [the refarch-eda-store-inventory project](https://github.com/ibm-cloud-architecture/refarch-eda-store-inventory) the output is in `store.inventory` topic. \n2. The mock up Inventory mainframe application is not implemented and we will use the MQ tools to view the message in the `item.inventory` MQ queue.\n\n \n\n","fileAbsolutePath":"/home/runner/work/refarch-eda/refarch-eda/docs/src/pages/scenarios/realtime-inventory/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550"]}